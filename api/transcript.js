
export default async function handler(req, res) {
  // CORS 설정
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
  
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  const { videoId } = req.query;
  if (!videoId) return res.status(400).json({ error: 'videoId 필요' });

  const SWARM_NODES = [
    "https://pipedapi.kavin.rocks",
    "https://api.piped.otter.sh",
    "https://piped-api.garudalinux.org",
    "https://pipedapi.tokhmi.xyz",
    "https://api.piped.projectsegfau.lt",
    "https://pipedapi.adminforge.de",
    "https://api.piped.yt.lo",
    "https://piped-api.lunar.icu",
    "https://pipedapi.system41.de"
  ];

  // 랜덤 순서로 노드 섞기 (부하 분산)
  const nodes = [...SWARM_NODES].sort(() => 0.5 - Math.random());

  // 1. Piped API 시도 (Swarm)
  for (const node of nodes) {
    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 4000); // 4초 타임아웃

      const response = await fetch(`${node}/streams/${videoId}`, {
        signal: controller.signal,
        headers: { 'User-Agent': 'Mozilla/5.0' }
      });
      clearTimeout(timeout);

      if (response.ok) {
        const data = await response.json();
        const subtitles = data.subtitles || [];
        
        // 우선순위: 한국어 -> 영어 -> 자동생성 아님 -> 첫번째
        const track = subtitles.find(s => s.code === 'ko' && !s.autoGenerated) ||
                     subtitles.find(s => s.code === 'en' && !s.autoGenerated) ||
                     subtitles.find(s => s.code === 'ko') ||
                     subtitles[0];

        if (track) {
          const subResponse = await fetch(track.url);
          if (subResponse.ok) {
            let text = await subResponse.text();
            // VTT 정리
            text = text.replace(/WEBVTT/g, '').replace(/\d{2}:\d{2}.*?\n/g, '').replace(/<[^>]+>/g, '').replace(/\n+/g, ' ').trim();
            
            return res.status(200).json({ success: true, content: text, source: new URL(node).hostname });
          }
        }
      }
    } catch (error) { continue; }
  }

  // 2. 직접 파싱 시도 (Fallback)
  try {
    const html = await fetch(`https://www.youtube.com/watch?v=${videoId}`, {
      headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' }
    }).then(r => r.text());

    const match = html.match(/"captionTracks":(\[.*?\])/);
    if (match) {
      const tracks = JSON.parse(match[1]);
      const track = tracks.find(t => t.languageCode === 'ko') || tracks[0];
      
      const xml = await fetch(track.baseUrl).then(r => r.text());
      const text = xml.replace(/<text.*?>(.*?)<\/text>/g, '$1 ').replace(/<[^>]+>/g, '').replace(/&#39;/g, "'").replace(/&quot;/g, '"').replace(/&amp;/g, '&').replace(/\s+/g, ' ').trim();

      return res.status(200).json({ success: true, content: text, source: 'direct-parse' });
    }
  } catch (error) { console.error(error); }

  return res.status(404).json({ success: false, error: '자막을 찾을 수 없습니다.' });
}